## 「Rubyによるデザインパターン」

refs: http://www.amazon.com/dp/0321490452

### 動的動機付け
* 渡されてくるオブジェクトが特定のクラスに属していないことを言語でチェックしないことを意味する
* テンプレートメソッドで言えば、クライアントが呼びだそうとしているメソッドをオブジェクトが実装していることが大事
* 型に対するこのアプローチはダックタイピングと呼ばれる

### ダックタイピング
* 「もしアヒルのように見えて、アヒルのように鳴くのなら、それはアヒルである」（"If it walks like a duck and quacks like a duck, it must be a duck."）

### GoF
* 変わるものを変わらないものから分離する
* インターフェイスに対してプログラムし、実装に対して行わない
* 継承より集約
* 委譲、委譲、委譲
* 必要になるまで作るな

### Template Method
* アルゴリズムに多様性を持たせたい場合に便利
* 変わるものと変わらないものを分離することができる
* 基底クラスに不変の部分を記述し、変わる部分はサブクラスに定義するメソッドにカプセル化する
* 基底クラスはメソッドを未定義にしておくことができる
* 未定義にする代わりに、基底クラスで標準実装を提供し、必要があればサブクラスでオーバーライドさせることもできる

### Strategy
* Strategyパターンは、Template Methodパターンと同様の問題に対する委譲ベースのアプローチによる解
* アルゴリズム中の変わる部分を抜き出してサブクラスへと押し込む代わりに、アルゴリズムのパターンごとにばらばらのオブジェクトとしてシンプルに実装
* 異なるストラテジオブジェクトをコンテキストに対して提供することで、アルゴリズムに多様性をもたらすことができる
* それぞれのストラテジオブジェクトは同じ仕事をこなすだけでなく、そのすべてが正確に同じインターフェイスを提供する
* 2つめ3つめのストラテジを設計に盛り込めないとStrategyパターンを利用する意味がないので、コンテキストとストラテジ間の結合度、インターフェイスの詳細には気を配る必要がある
* Observerパターンと類似しているが、Strategyパターンの背後にある動機は、アルゴリズムのバリエーションをどうやって演じたらよいかを知っているオブジェクトを提供すること

### Observer
* ニュースを発信源（Subject, Observable）から消費者（Observer）へ伝えるインターフェースを提供する
* オブジェクト同士を強固に結合させることがないので、制御不能なスパゲッティプログラムにならなくて済む
* 実装としては、オブザーバを保持するための配列、配列を管理するための2つのメソッド、変更が発生したときの通知用のメソッドのみ
* Strategyパターン
  * 何かの処理を行うためにそのストラテジオブジェクトを取得することが目的
* Observerパターン
  * オブザーバブルオブジェクトで発生しているイベントを他のオブジェクトに伝えることが目的

### Iterator
* 集約オブジェクトがもとにある内部表現を公開せずに、その要素に順にアクセスする方法を提供する
* 外部イテレータ
  * イテレータオブジェクトを提供することによって、集約を走査
  * 次の要素の準備ができるまで次を呼び出さない
  * 他のメソッドやオブジェクトに共有可能
* 内部イテレータ
  * 集約は項目を次々とコードブロックへ絶え間なく渡す
  * シンプルでわかりやすい

### Command
* ある**特定**の動作を実行するオブジェクトを構築
  * 「特定」という部分が重要
  * ex. コマンドの内容と実行を分離
* Observerパターンとの共通点多い
  * Command: 何かを行う方法を知っているだけで、それを実行する対象の状態には関心がない
  * Observer: 呼び出される対象の状態にとても関心がある

### Adapter
* 既存のインターフェイスと必要なインターフェイスとの間の深い溝を橋渡しを行う
* 他の方法として、不適切なインターフェイスを持ったオブジェクトを、適切なインターフェイスを持つように変更することでも実現可能
  * クラスやインスタンスの変更
    * 変更内容がシンプルで、変更するクラス・インスタンスとその使用方法を理解している場合に適している
  * アダプタパターン
    * インターフェイスの不整合が広範囲に及び複雑で、そのクラスやインスタンスがどのように動くかわからない場合に適している

### Proxy
* 自分とは違う他のオブジェクトのフリをし、本物のオブジェクトへの参照をプロキシー内部に隠す。これにより、下記の問題への解決策を提供。
  1. 権限のないアクセスからのオブジェクトの防御
  1. ネットワーク上の他の場所にオブジェクトが存在するという事実の隠蔽
  1. 生成コストのかかるオブジェクトのインスタンス化の遅延
* 要するに、プロキシーはサブジェクトへのアクセスを制御する
* アダプタが内部のオブジェクトのインターフェイスを変換するのに対し、プロキシーは内部のオブジェクトへのアクセスを制御する

### Decorator
* 基本的な機能から始め、拡張機能のデコレータを1つずつレイヤ状に重ねていき、実行時に組み立てる
* 基本的な機能をカバーする1つのクラスと、それと組になる一式のデコレータを作成
* Decoratorパターンは「別のオブジェクトの代理オブジェクト」の最後のパターン
  1. Adapter: 不適切なインターフェイスを持ったオブジェクトを正しいインターフェイスのオブジェクトでラップする
  1. Proxy: インターフェイスを変える意図はなく、ラップするオブジェクトと同じインターフェイスを持ち、コントロールする
  1. Decorator: 基本的なオブジェクトにレイヤ状に機能を追加できるようにする
